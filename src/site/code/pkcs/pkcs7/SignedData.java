package org.xpertss.crypto.pkcs.pkcs7;


import org.xpertss.crypto.asn1.*;
import org.xpertss.crypto.pkcs.AlgorithmIdentifier;

import java.security.cert.X509Certificate;
import java.util.*;

/**
 * The signatures generated by this class are compatible to Sun's <code>jarsigner</code>.
 * The actual bytes being signed are denoted <i>payload</i> in this documenatation, in
 * order to differentiate between the signing of arbitrary (opaque) data and the DER
 * encoding of registered ASN.1 structures such as EnvelopedData.
 * <p/>
 * Presently, only content of type {@link Data Data} is supported. Either detached
 * signatures may be generated (in which case the content consists of a {@link Data Data}
 * type with no content) or the payload may be embedded into the content info of this
 * structure (automatically wrapped into a {@link Data Data} type.
 * <p/>
 * Use {@link SignerInfo SignerInfo} instances for signing and verifying instances of
 * this class such as illustrated in the code example below. This example shows how to
 * verify a detached signature on a file. One PKCS#7 structure may contain multiple
 * signatures. In the example given below, all of them are verified.
 * <p/>
 * The definition of this structure is:
 * <blockquote><pre>
 * SignedData ::= SEQUENCE {
 *   version Version,
 *   digestAlgorithms DigestAlgorithmIdentifiers,
 *   contentInfo ContentInfo,
 *   certificates
 *     [0] IMPLICIT ExtendedCertificatesAndCertificates OPTIONAL,
 *   crls
 *     [1] IMPLICIT CertificateRevocationLists OPTIONAL,
 *   signerInfos SignerInfos
 * }
 *
 * DigestAlgorithmIdentifiers ::= SET OF DigestAlgorithmIdentifier
 *
 * SignerInfos ::= SET OF SignerInfo
 * </pre></blockquote>
 * <p/>
 * Please note that <code>SignerInfo</code> structures only store the issuer and serial
 * number of the signing certificate but not the certificate itself. Neither are
 * certificates added automatically by this class when signing is done. If a certificate
 * shall be included with an instance of this class then it must be added explicitly by
 * calling <code>addCertificate(..)</code>.
 */
public class SignedData extends ASN1Sequence implements ASN1RegisteredType, Signable {
   /**
    * The OID of this structure. PKCS#7 SignedData.
    */
   private static final int[] THIS_OID = {1, 2, 840, 113549, 1, 7, 2};

   /**
    * The PKCS#7 Data OID.
    */
   private static final int[] DATA_OID = {1, 2, 840, 113549, 1, 7, 1};

   /**
    * The DigestAlgorithmIdentifiers.
    */
   protected ASN1Set digestID_;

   /**
    * The X.509 certificates.
    */
   protected Certificates certs_;

   /**
    * The {@link SignerInfo SignerInfos}.
    */
   protected ASN1SetOf infos_;

   /**
    * The revocation lists.
    */
   protected ASN1Set crls_;

   /**
    * The {@link ContentInfo ContentInfo}.
    */
   protected ContentInfo content_;



   /**
    * Creates an instance ready for decoding.
    */
   public SignedData()
   {
      super(6);

      add(new ASN1Integer(1)); // version

      digestID_ = new ASN1SetOf(AlgorithmIdentifier.class);
      add(digestID_);

      content_ = new ContentInfo();
      add(content_);

      certs_ = new Certificates();
      add(new ASN1TaggedType(0, certs_, false, true));

      crls_ = new ASN1SetOf(ASN1Opaque.class);
      add(new ASN1TaggedType(1, crls_, false, true));

      infos_ = new ASN1SetOf(SignerInfo.class);
      add(infos_);
   }





   /**
    * This method retrieves the content of this structure,
    * consisting of the ASN.1 type embedded in the {@link
    * #content_ ContentInfo} structure. Beware, the content
    * type might be faked by adversaries, if it is not of
    * type {@link Data Data}. If it is not data then the
    * authenticated content type must be given as an
    * authenticated attribute in all the {@link SignerInfo
    * SignerInfo} structures.
    *
    * @return The contents octets.
    */
   public ASN1Type getContent()
   {
      return content_.getContent();
   }


   /**
    * Sets the content type to the given OID. The content
    * itself is set to <code>null</code>. This method should
    * be called if the content to be signed is external (not
    * inserted into this structure).<p>
    *
    * If this structure is signed with the {@link Signer
    * Signer} then the {@link SignerInfo SignerInfo} that
    * is passed to it must have either:
    * <ul>
    * <li> no authenticated content type attribute, or
    * <li> the authenticated content type attribute must
    *   match <code>oid</code>.
    * </ul>
    * In the first case, a new authenticated content type
    * attribute with <code>oid</code> as its value will be
    * added to the <code>SignerInfo</code> automatically
    * (if the content type is not {@link Data Data} or at
    * least one other authenticated attribute is already
    * in that <code>SignerInfo</code>.
    *
    * @param oid The OID that identifies the content
    *   type of the signed data.
    * @exception NullPointerException if <code>oid</code>
    *   is <code>null</code>.
    */
   public void setContentType(ASN1ObjectIdentifier oid)
   {
      if (oid == null)
         throw new NullPointerException("OID");
      content_.setContent(oid);
   }


   /**
    * Sets the content to be embedded into this instance's
    * <code>ContentInfo</code>.
    *
    * @param t The actual content.
    */
   public void setContent(ASN1RegisteredType t)
   {
      if (t == null)
         throw new NullPointerException("Need content!");
      content_.setContent(t);
   }


   /**
    * Sets the content to be embedded into this instance's
    * <code>ContentInfo</code>.
    *
    * @param oid The object identifier of the content.
    * @param t The actual content.
    */
   public void setContent(ASN1ObjectIdentifier oid, ASN1Type t)
   {
      if (oid == null || t == null)
         throw new NullPointerException("Need an OID and content!");
      content_.setContent(oid, t);
   }


   /**
    * Returns the content type of the content embedded
    * in this structure. The returned OID is a copy, no side
    * effects are caused by modifying it.
    *
    * @return The content type of this structure's payload.
    */
   public ASN1ObjectIdentifier getContentType()
   {
      return (ASN1ObjectIdentifier) content_.getContentType().copy();
   }








   /**
    * Returns the OID of this structure. The returned OID is
    * a copy, no side effects are caused by modifying it.
    *
    * @return The OID.
    */
   public ASN1ObjectIdentifier getOID()
   {
      return new ASN1ObjectIdentifier(THIS_OID);
   }




   /**
    * This method returns the certificates stored in this structure.
    *
    * @return The set of Certificates
    */
   public Certificates getCertificates()
   {
      return certs_;
   }


   /**
    * This method returns the {@link SignerInfo
    * SignerInfos} of the signers of this structure.
    *
    * @return The unmodifiable view of the list of SignerInfos.
    */
   public List getSignerInfos()
   {
      // TODO Optimize this and generify it
      return (List) infos_.getValue();
   }


   /**
    * Returns the <code>SignerInfo</code> that matches the
    * given certificate.
    *
    * @param cert The certificate matching the <code>SignerInfo
    *   </code> to be retrieved.
    * @return The <code>SignerInfo</code> or <code>null</code>
    *   if no matching one is found.
    */
   public SignerInfo getSignerInfo(X509Certificate cert)
   {
      for (Iterator i = getSignerInfos().iterator(); i.hasNext();) {
         SignerInfo info = (SignerInfo) i.next();
         if (!info.getIssuerDN().equals(cert.getIssuerDN())) continue;
         if (info.getSerialNumber().equals(cert.getSerialNumber())) return info;
      }
      return null;
   }


   /**
    * Returns a string representation of this object.
    *
    * @return The string representation.
    */
   public String toString()
   {
      return "-- PKCS#7 SignedData --\n" + super.toString();
   }


   /**
    * Adds the given {@link SignerInfo SignerInfo} to this
    * instance. This method should be used rarely. In general,
    * the signing methods take care of adding <code>SignerInfo
    * </code> instances. Explicit adding of a <code>SignerInfo
    * </code> is provided only in those cases where fine control
    * of the creation of signatures is required.
    *
    * @param info The <code>SignerInfo</code> to add.
    * @exception NullPointerException if the <code>info</code>
    *   is <code>null</code>.
    */
   public void addSignerInfo(SignerInfo info)
   {
      Iterator i;

      if (info == null)
         throw new NullPointerException("Need a SignerInfo!");
      infos_.add(info);

      /* We also have to add the DigestAlgorithmIdentifier
       * of the SignerInfo to the list of digest algs if it
       * is not yet in the list.
       */
      AlgorithmIdentifier idn = info.getDigestAlgorithmIdentifier();

      for (i = digestID_.iterator(); i.hasNext();) {
         AlgorithmIdentifier idv = (AlgorithmIdentifier) i.next();
         if (idn.equals(idv)) return;
      }
      digestID_.add(idn);
   }


}


