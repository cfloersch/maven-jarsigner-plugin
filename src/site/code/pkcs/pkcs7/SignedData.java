package org.xpertss.crypto.pkcs.pkcs7;


import org.xpertss.crypto.asn1.*;
import org.xpertss.crypto.pkcs.AlgorithmIdentifier;

import java.security.cert.X509Certificate;
import java.util.*;

/**
 * The signatures generated by this class are compatible to Sun's <code>jarsigner</code>.
 * The actual bytes being signed are denoted <i>payload</i> in this documenatation, in
 * order to differentiate between the signing of arbitrary (opaque) data and the DER
 * encoding of registered ASN.1 structures such as EnvelopedData.
 * <p/>
 * Presently, only content of type {@link Data Data} is supported. Either detached
 * signatures may be generated (in which case the content consists of a {@link Data Data}
 * type with no content) or the payload may be embedded into the content info of this
 * structure (automatically wrapped into a {@link Data Data} type.
 * <p/>
 * Use {@link SignerInfo SignerInfo} instances for signing and verifying instances of
 * this class such as illustrated in the code example below. This example shows how to
 * verify a detached signature on a file. One PKCS#7 structure may contain multiple
 * signatures. In the example given below, all of them are verified.
 * <p/>
 * The definition of this structure is:
 * <blockquote><pre>
 * SignedData ::= SEQUENCE {
 *   version Version,
 *   digestAlgorithms DigestAlgorithmIdentifiers,
 *   contentInfo ContentInfo,
 *   certificates
 *     [0] IMPLICIT ExtendedCertificatesAndCertificates OPTIONAL,
 *   crls
 *     [1] IMPLICIT CertificateRevocationLists OPTIONAL,
 *   signerInfos SignerInfos
 * }
 *
 * DigestAlgorithmIdentifiers ::= SET OF DigestAlgorithmIdentifier
 *
 * SignerInfos ::= SET OF SignerInfo
 * </pre></blockquote>
 * <p/>
 * Please note that <code>SignerInfo</code> structures only store the issuer and serial
 * number of the signing certificate but not the certificate itself. Neither are
 * certificates added automatically by this class when signing is done. If a certificate
 * shall be included with an instance of this class then it must be added explicitly by
 * calling <code>addCertificate(..)</code>.
 */
public class SignedData extends ASN1Sequence implements ASN1RegisteredType, Signable {
   /**
    * The OID of this structure. PKCS#7 SignedData.
    */
   private static final int[] THIS_OID = {1, 2, 840, 113549, 1, 7, 2};

   /**
    * The PKCS#7 Data OID.
    */
   private static final int[] DATA_OID = {1, 2, 840, 113549, 1, 7, 1};

   /**
    * The DigestAlgorithmIdentifiers.
    */
   protected ASN1Set digestID;

   /**
    * The X.509 certificates.
    */
   protected Certificates certs;

   /**
    * The {@link SignerInfo SignerInfos}.
    */
   protected ASN1SetOf signers;

   /**
    * The revocation lists.
    */
   protected ASN1Set crls;

   /**
    * The {@link ContentInfo ContentInfo}.
    */
   protected ContentInfo content;



   /**
    * Creates an instance ready for decoding.
    */
   public SignedData()
   {
      super(6);

      add(new ASN1Integer(1)); // version

      digestID = new ASN1SetOf(AlgorithmIdentifier.class);
      add(digestID);

      content = new ContentInfo();
      add(content);

      certs = new Certificates();
      add(new ASN1TaggedType(0, certs, false, true));

      crls = new ASN1SetOf(ASN1Opaque.class);
      add(new ASN1TaggedType(1, crls, false, true));

      signers = new ASN1SetOf(SignerInfo.class);
      add(signers);
   }





   /**
    * This method retrieves the content of this structure, consisting of the ASN.1 type
    * embedded in the {@link ContentInfo} structure. Beware, the content type might be faked
    * by adversaries, if it is not of type {@link Data}. If it is not data then the
    * authenticated content type must be given as an authenticated attribute in all the {@link
    * SignerInfo} structures.
    *
    * @return The contents octets.
    */
   public ASN1Type getContent()
   {
      return content.getContent();
   }


   /**
    * Sets the content type to the given OID. The content itself is set to <code>null</code>.
    * This method should be called if the content to be signed is external (not inserted into
    * this structure).
    * <p/>
    * If this structure is signed with the {@link Signer} then the {@link SignerInfo} that is
    * passed to it must have either:
    * <ul>
    * <li> no authenticated content type attribute, or
    * <li> the authenticated content type attribute must match <code>oid</code>.
    * </ul>
    * In the first case, a new authenticated content type attribute with <code>oid</code> as
    * its value will be added to the <code>SignerInfo</code> automatically (if the content type
    * is not {@link Data} or at least one other authenticated attribute is already in that
    * <code>SignerInfo</code>.
    *
    * @param oid The OID that identifies the content type of the signed data.
    * @exception NullPointerException if <code>oid</code> is <code>null</code>.
    */
   public void setContentType(ASN1ObjectIdentifier oid)
   {
      if (oid == null) throw new NullPointerException("OID");
      content.setContent(oid);
   }


   /**
    * Sets the content to be embedded into this instance's <code>ContentInfo</code>.
    *
    * @param t The actual content.
    */
   public void setContent(ASN1RegisteredType t)
   {
      if (t == null) throw new NullPointerException("Need content!");
      content.setContent(t);
   }


   /**
    * Sets the content to be embedded into this instance's <code>ContentInfo</code>.
    *
    * @param oid The object identifier of the content.
    * @param t The actual content.
    */
   public void setContent(ASN1ObjectIdentifier oid, ASN1Type t)
   {
      if (oid == null || t == null)
         throw new NullPointerException("Need an OID and content!");
      content.setContent(oid, t);
   }


   /**
    * Returns the content type of the content embedded in this structure. The returned OID is
    * a copy, no side effects are caused by modifying it.
    *
    * @return The content type of this structure's payload.
    */
   public ASN1ObjectIdentifier getContentType()
   {
      return (ASN1ObjectIdentifier) content.getContentType().copy();
   }








   /**
    * Returns the OID of this structure. The returned OID is a copy, no side effects are
    * caused by modifying it.
    *
    * @return The OID.
    */
   public ASN1ObjectIdentifier getOID()
   {
      return new ASN1ObjectIdentifier(THIS_OID);
   }




   /**
    * This method returns the certificates stored in this structure.
    *
    * @return The set of Certificates
    */
   public Certificates getCertificates()
   {
      return certs;
   }


   /**
    * This method returns the {@link SignerInfo} of the signers of this structure.
    *
    * @return The unmodifiable view of the list of SignerInfos.
    */
   public List getSignerInfos()
   {
      // TODO Optimize this and generify it
      return (List) signers.getValue();
   }


   /**
    * Returns the <code>SignerInfo</code> that matches the given certificate.
    *
    * @param cert The certificate matching the <code>SignerInfo</code> to be retrieved.
    * @return The <code>SignerInfo</code> or <code>null</code> if no matching one is found.
    */
   public SignerInfo getSignerInfo(X509Certificate cert)
   {
      for (Iterator i = getSignerInfos().iterator(); i.hasNext();) {
         SignerInfo info = (SignerInfo) i.next();
         if (!info.getIssuerDN().equals(cert.getIssuerDN())) continue;
         if (info.getSerialNumber().equals(cert.getSerialNumber())) return info;
      }
      return null;
   }


   /**
    * Returns a string representation of this object.
    *
    * @return The string representation.
    */
   public String toString()
   {
      return "-- PKCS#7 SignedData --\n" + super.toString();
   }


   /**
    * Adds the given {@link SignerInfo} to this instance. This method should be used rarely. In
    * general, the signing methods take care of adding <code>SignerInfo</code> instances.
    * Explicit adding of a <code>SignerInfo</code> is provided only in those cases where fine
    * control of the creation of signatures is required.
    *
    * @param info The <code>SignerInfo</code> to add.
    * @exception NullPointerException if the <code>info</code> is <code>null</code>.
    */
   public void addSignerInfo(SignerInfo info)
   {
      if (info == null) throw new NullPointerException("Need a SignerInfo!");
      signers.add(info);

      /* We also have to add the DigestAlgorithmIdentifier
       * of the SignerInfo to the list of digest algs if it
       * is not yet in the list.
       */
      AlgorithmIdentifier idn = info.getDigestAlgorithmIdentifier();

      for (Iterator i = digestID.iterator(); i.hasNext();) {
         AlgorithmIdentifier idv = (AlgorithmIdentifier) i.next();
         if (idn.equals(idv)) return;
      }
      digestID.add(idn);
   }


}


